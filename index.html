<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>画像切り取りカメラ（HTML版 v2）</title>
<style>
  :root{
    --bg:#0b0f14;
    --fg:#e9f0f5;
    --muted:#9fb0be;
    --accent:#2ecc71;
    --accent-2:#e74c3c;
    --card:#141a21;
    --btn:#1f2833;
    --ring:#27ae60;
    --yellow:#f1c40f;
  }
  html,body{
    margin:0;
    height:100%;
    background:var(--bg);
    color:var(--fg);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN","Yu Gothic",sans-serif;
  }
  .app{ display:flex; flex-direction:column; height:100%; }
  header, footer{ padding: env(safe-area-inset-top) 16px 8px 16px; }
  header{
    display:flex; flex-direction:column; gap:10px;
    background:linear-gradient(180deg, #101723, #0b0f14 60%);
    box-shadow: 0 1px 0 rgba(255,255,255,0.05) inset;
  }
  .row{ display:flex; align-items:center; gap:12px; flex-wrap:wrap; }
  .title{ font-weight:700; letter-spacing:0.3px; font-size: clamp(16px, 2.8vw, 22px); }
  .grow{ flex:1; }
  .chip, .toggle, .btn, .link-like{
    border-radius:14px; border:1px solid rgba(255,255,255,0.08);
    background:var(--btn); color:var(--fg); font-weight:700;
  }
  .chip{ padding:10px 12px; font-size:14px; }
  .chip[data-active="true"]{ outline:2px solid var(--ring); background: rgba(46,204,113,0.12); }
  .control{ display:flex; align-items:center; gap:10px; background:var(--card); padding:10px 12px; border-radius:14px; box-shadow:0 2px 8px rgba(0,0,0,0.25); }
  .control label{ color:var(--muted); font-size: 13px; }
  input[type="range"]{ width: min(52vw, 420px); touch-action: pan-y; }
  .toggle{ padding:12px 14px; font-size:14px; }
  .toggle[data-active="true"]{ outline: 2px solid var(--ring); background: rgba(46,204,113,0.12); }
  .toggle.warn[data-active="true"]{ outline-color: var(--yellow); background: rgba(241,196,15,0.12); }
  .link-like{ background:transparent; color:var(--muted); }
  .stage{ position:relative; flex:1; min-height: 40vh; overflow:hidden; margin: 8px 0; }
  video#preview{ position:absolute; inset:0; width:100%; height:100%; object-fit:contain; background:#000; }
  canvas#overlay{ position:absolute; inset:0; width:100%; height:100%; touch-action:none; }
  .flash{ position:absolute; inset:0; background:#fff; opacity:0; pointer-events:none; transition: opacity 120ms ease-out; }
  footer{
    padding: 10px 16px calc(10px + env(safe-area-inset-bottom)) 16px;
    display:flex; gap:12px; align-items:center; justify-content:space-between;
    background:linear-gradient(0deg, #101723, #0b0f14 60%); border-top: 1px solid rgba(255,255,255,0.05);
  }
  .btn{
    border:none; padding:18px 26px; font-size: clamp(18px, 4.2vw, 22px);
    background: var(--accent); color:#02130a; box-shadow: 0 6px 24px rgba(46,204,113,0.35);
  }
  .btn:active{ transform: translateY(1px); }
  .btn.secondary{ background: var(--accent-2); color:#fff; box-shadow:0 6px 24px rgba(231,76,60,0.35); }
  .btn.ghost{ background:transparent; color:var(--muted); border:1px solid rgba(255,255,255,0.15); }
  .stack{ display:flex; align-items:center; gap:12px; flex-wrap:wrap; }
  .hidden{ display:none; }
  .hint{ color:var(--muted); font-size:12px; }

  /* iPhoneカメラ風 白丸シャッターボタン */
  .btn-capture{
    width:90px;
    height:90px;
    border-radius:50%;
    background:#fff;
    border:6px solid #ccc;
    box-shadow:0 4px 14px rgba(0,0,0,0.35);
    display:flex;
    align-items:center;
    justify-content:center;
  }
  .btn-capture:active{
    transform: scale(0.92);
    border-color:#999;
  }

  /* Ensure top stage is visible at the top */
  .stage{ min-height: 42vh; }

  /* Accessible visually-hidden file input (for iOS Safari) */
  .visually-hidden-file{
    position:absolute !important;
    width:1px !important;
    height:1px !important;
    padding:0 !important;
    margin:-1px !important;
    overflow:hidden !important;
    clip: rect(0 0 0 0) !important;
    white-space: nowrap !important;
    border:0 !important;
    clip-path: inset(50%) !important;
  }

  /* Photo preview shown in stage when selecting from gallery */
  #photo-preview{
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
    object-fit:contain;
    display:none; /* hidden until a photo is selected */
    background:#000;
  }

  /* Full-screen camera overlay (iPhone friendly) */
  html, body { height:100%; min-height:100%; margin:0; padding:0; background:#000; }
  .stage-container{ position:relative; }
  .stage{ position:relative; }

  /* media layers fill the stage */
  .stage > video#preview,
  .stage > img#photo-preview,
  .stage > canvas#overlay{
    position:absolute; inset:0; width:100%; height:100%; object-fit:contain;
  }

  /* Overlay toggle button */
  .fs-btn{
    position:absolute; top:calc(env(safe-area-inset-top) + 8px); right:8px;
    z-index:1000; border:1px solid #888; background:rgba(0,0,0,.45); color:#fff;
    padding:8px 10px; border-radius:999px; font-size:14px;
    backdrop-filter: blur(4px);
  }

  /* Fullscreen state */
  .shoot-full{
    position:fixed; inset:0;
    width:100vw;
    height:100svh;
    z-index:9990; background:#000;
  }
  @supports (height: 100lvh){
    .shoot-full{ height:100lvh; }
  }
  @supports (height: 100dvh){
    .shoot-full{ height:100dvh; }
  }
  @supports (-webkit-touch-callout: none){
    .shoot-full{ height:-webkit-fill-available; }
  }
  .shoot-full > .stage{ width:100%; height:100%; }

  /* Hide non-camera UI in fullscreen */
  body.fullscreen .app-title,
  body.fullscreen header,
  body.fullscreen footer{ display:none !important; }

  /* Option: emphasize cover to maximize visuals in fullscreen */
  body.fullscreen .stage > video#preview,
  body.fullscreen .stage > img#photo-preview{
    object-fit: cover;
  }

  /* Fullscreen shutter (bottom-center) */
  .fs-shutter{
    position:absolute;
    left:50%;
    transform: translateX(-50%);
    bottom: calc(env(safe-area-inset-bottom) + 16px);
    z-index: 1001;
    width: 72px;
    height: 72px;
    border-radius: 50%;
    background: #fff;
    border: none;
    box-shadow: 0 2px 12px rgba(0,0,0,.35), inset 0 0 0 2px rgba(255,255,255,.9);
    display: none; /* show only in fullscreen */
  }
  body.fullscreen .fs-shutter{ display: block; }

  /* Hide default capture button in fullscreen (avoid duplicate) */
  body.fullscreen #capture{ display:none !important; }

  /* Capture row background */
  .capture-row{ background:#000; }

  /* Label left of size chips */
  .chips-label{
    display:inline-block;
    margin-right: 10px;
    font-size: 14px;
    color: #fff;
    opacity: 0.9;
    letter-spacing: 0.02em;
  }
  /* If header has light background, keep contrast */
  header .chips-label{ color: inherit; opacity: 0.9; }
</style>
</head>
<body>
<div class="app">
  <div class="app-title" style="text-align:center; font-weight:700; font-size:20px; padding:10px;">画像切り取りカメラ（HTML版 v2）</div>

  <!-- TOP: camera + shutter -->

  <div class="stage-container">
<main class="stage" id="stage">
    <video id="preview" playsinline autoplay muted></video>
    <img id="photo-preview" alt="" />
    <canvas id="overlay"></canvas>
    <div class="flash" id="flash"></div>
  </main>
    <button id="fs-shutter" class="fs-shutter" aria-label="撮影"></button>
    <!-- Fullscreen toggle button overlay -->
    <button id="fs-toggle" class="fs-btn"><span id="fs-toggle-label">全画面</span></button>
  </div>

  

  <header>
    <div class="row capture-row">
      
      <button id="switch-source" class="toggle" title="前面/背面を切替">カメラ切替</button>
      <div class="grow"></div>
      <button id="share-latest" class="toggle link-like" title="直近の保存画像を共有">共有</button>
    </div>
    <div class="row">
      
      </div>
    <div class="row">
      <div class="control" aria-label="丸枠サイズ">
        <div class="chips"><span class="chips-label" aria-hidden="true">丸枠</span>
      <button class="chip" data-size="0.35" data-active="true" aria-pressed="true">S</button>
          <button class="chip" data-size="0.42" data-active="false" aria-pressed="false">M</button>
          <button class="chip" data-size="0.50" data-active="false" aria-pressed="false">L</button>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="control">
        <label for="quality">JPEG画質</label>
        <input id="quality" type="range" min="60" max="95" step="1" value="85" />
        <span id="qv" aria-hidden="true">85</span>
      </div>
    </div>
    <div class="row">
      
      <button id="grid" class="toggle" data-active="true" aria-pressed="true">グリッド</button>
      <button id="lock" class="toggle warn" data-active="false" title="ドラッグを無効化">ロック</button>
      <button id="recenter" class="toggle">中央に戻す</button>
      <button id="fit-inside" class="toggle" data-active="true" title="丸枠を映像内に制限">枠のはみ出し防止</button>
    
    </div>
</div>
    <div class="row">
      
      <div id="zoom-wrap" class="control hidden">
        <label for="zoom">ズーム</label>
        <input id="zoom" type="range" min="1" max="1" step="0.1" value="1" />
        <span id="zv">1.0×</span>
      </div>
      <input id="file-fallback" class="visually-hidden-file" type="file" accept="image/*" capture="environment">
      <label id="pick-file" class="toggle link-like" for="file-fallback">写真から読み込む</label> <button id="back-to-camera" class="toggle link-like hidden" style="margin-left:8px;">戻る</button> <button id="stop" class="toggle" style="margin-left:8px;">再開</button>
    </div>
  </header>
<div class="row" style="justify-content:center; margin:8px 0;">
<div style="flex:0; display:flex; flex-direction:column; align-items:center; justify-content:center;">
      <button id="capture" class="btn btn-capture"></button>
      <a id="dl" class="toggle link-like hidden" download style="margin-top:8px;">保存リンクを開く</a>
    </div>
  </div>

  
  
  
  <footer style="display:flex; align-items:center; justify-content:center; gap:8px; width:100%; padding:12px 0;">
    <div class="hint">iPhoneはHTTPSでアクセス。保存はリンク長押しでもOK。</div>
  </footer>




  

  

  
  
</div>

<script>
(function(){
// --- Size chips only mode (slider optional) ---
  function getActiveChipSize(){
    const active = document.querySelector('.chip[data-active="true"]');
    if (active) return parseFloat(active.dataset.size);
    const first = document.querySelector('.chip[data-size]');
    return first ? parseFloat(first.dataset.size) : 0.42; // fallback M
  }
  function markActiveChip(target){
    document.querySelectorAll('.chip[data-size]').forEach(b => b.setAttribute('data-active','false'));
    if (target) target.setAttribute('data-active','true');
  }
const video = document.getElementById('preview');
  const overlay = document.getElementById('overlay');
  const ctx = overlay.getContext('2d');
  const stage = document.getElementById('stage');
  const flash = document.getElementById('flash');

  
  // Camera running state
  let cameraPaused = false;
const sizeSlider = document.getElementById('size');
  const sizeChips = [...document.querySelectorAll('.chip')];
  sizeChips.forEach(btn => {
    btn.addEventListener('click', function(){
      const v = parseFloat(this.dataset.size);
      if (Number.isFinite(v)) { radiusPct = v; }
      markActiveChip(this);
      drawOverlay();
    });
  });
  const qualitySlider = document.getElementById('quality');
  const qv = document.getElementById('qv');
  const gridBtn = document.getElementById('grid');
  const lockBtn = document.getElementById('lock');
  const recenterBtn = document.getElementById('recenter');
  const fitBtn = document.getElementById('fit-inside');
  const captureBtn = document.getElementById('capture');
  const stopBtn = document.getElementById('stop');
  const switchBtn = document.getElementById('switch-source');
  const dl = document.getElementById('dl');
  const backBtn = document.getElementById('back-to-camera');
  const pickBtn = document.getElementById('pick-file');
  const fileInput = document.getElementById('file-fallback');
  const shareBtn = document.getElementById('share-latest');
  const photoPreview = document.getElementById('photo-preview');
  let usingPhoto = false; let photoObjUrl = null; let photoBitmap = null;

  const zoomWrap = document.getElementById('zoom-wrap');
  const zoomSlider = document.getElementById('zoom');
  const zv = document.getElementById('zv');

  let showGrid = true;
  let radiusPct = getActiveChipSize();
  let cxNorm = 0.5; // 0..1
  let cyNorm = 0.5;
  let currentStream = null;
  let facingMode = 'environment';
  let latestBlobUrl = null;
  let track = null;
  let caps = null;
  let settings = null;
  let fitInside = true;
  let locked = false;

  
  function clearPhotoPreview(){
    usingPhoto = false;
    if (photoPreview){
      photoPreview.src = '';
      photoPreview.style.display = 'none';
      updateStageVisual();
    }
    if (photoObjUrl){
      try{ URL.revokeObjectURL(photoObjUrl); }catch(_e){}
      photoObjUrl = null;
    }
    photoBitmap = null;
    usingPhoto = false;
  }

  async function loadBitmap(file){
    if (window.createImageBitmap){
      try{ return await loadBitmap(file); }catch(_e){ /* fallback */ }
    }
    return await new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = URL.createObjectURL(file);
    });
  }


  const OUTPUT_SIZE = 1080;

  function setActive(el, active){ el.dataset.active = active ? 'true' : 'false'; }
  function isActive(el){ return el.dataset.active === 'true'; }

  function setHint(el, text){ el.textContent = text; }

  function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }

  function formatTS(d){
    const z = n => String(n).padStart(2,'0');
    return d.getFullYear().toString()
      + z(d.getMonth()+1) + z(d.getDate()) + '_' + z(d.getHours()) + z(d.getMinutes()) + z(d.getSeconds());
  }

  async function startCamera(){
    clearPhotoPreview();
    if (backBtn) backBtn.classList.add('hidden');
    updateStageVisual();
    stopCamera();
    const constraints = {
      audio:false,
      video:{
        facingMode: { ideal: facingMode },
        width: { ideal: 1920 },
        height: { ideal: 1080 },
        frameRate: { ideal: 30 },
        advanced: [
          { focusMode: "continuous" },
          { exposureMode: "continuous" }
        ]
      }
    };
    try{
      currentStream = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject = currentStream;
      await video.play();
      track = currentStream.getVideoTracks()[0];
      try {
        caps = track.getCapabilities?.() || null;
        settings = track.getSettings?.() || null;
        if (caps && caps.zoom){
          const min = caps.zoom.min || 1;
          const max = caps.zoom.max || 1;
          zoomSlider.min = min;
          zoomSlider.max = max;
          zoomSlider.step = caps.zoom.step || 0.1;
          zoomSlider.value = settings.zoom || 1;
          zv.textContent = (parseFloat(zoomSlider.value)).toFixed(1) + '×';
          zoomWrap.classList.remove('hidden');
        } else {
          zoomWrap.classList.add('hidden');
        }
      } catch(e){ zoomWrap.classList.add('hidden'); }

      requestAnimationFrame(drawOverlay);
    }catch(err){
      console.warn('getUserMedia失敗:', err);
      pickBtn.classList.remove('hidden'); // Fallback: file picker
    }
  }

  function stopCamera(){
    if(currentStream){
      currentStream.getTracks().forEach(t => t.stop());
      currentStream = null;
      track = null;
    }
  }

  function updateOverlaySize(){
    overlay.width = stage.clientWidth;
    overlay.height = stage.clientHeight;
  }

  function ensureInside(cx, cy, r){
    if(!fitInside) return [cx, cy];
    // compute displayed video rect
    const {drawW, drawH, offsetX, offsetY} = displayedDrawRect();
    const left = offsetX + r;
    const right = offsetX + drawW - r;
    const top = offsetY + r;
    const bottom = offsetY + drawH - r;
    const cw = stage.clientWidth, ch = stage.clientHeight;
    const px = clamp(cx, left, right) / cw;
    const py = clamp(cy, top, bottom) / ch;
    return [px *  cw / cw, py * ch / ch]; // keep as normalized later
  }

  function drawOverlay(){
    updateOverlaySize();
    const w = overlay.width, h = overlay.height;
    ctx.clearRect(0,0,w,h);

    let r = Math.min(w,h) * radiusPct;
    let cx = cxNorm * w;
    let cy = cyNorm * h;

    if (fitInside){
      // clamp center so circle stays within the displayed video area
      const {drawW, drawH, offsetX, offsetY} = displayedDrawRect();
      cx = clamp(cx, offsetX + r, offsetX + drawW - r);
      cy = clamp(cy, offsetY + r, offsetY + drawH - r);
      cxNorm = cx / w;
      cyNorm = cy / h;
    }

    // dark outside ring
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0,0,w,h);
    ctx.globalCompositeOperation = 'destination-out';
    ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
    ctx.restore();

    // ring
    ctx.save();
    ctx.strokeStyle = '#000'; ctx.lineWidth = 6;
    ctx.beginPath(); ctx.arc(cx,cy,r+6,0,Math.PI*2); ctx.stroke();
    ctx.strokeStyle = '#00FF66'; ctx.lineWidth = 4;
    ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.stroke();

    if(isActive(gridBtn)){
      ctx.strokeStyle = 'rgba(255,255,255,0.9)'; ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(cx - r, cy); ctx.lineTo(cx + r, cy);
      ctx.moveTo(cx, cy - r); ctx.lineTo(cx, cy + r);
      const rr = r / Math.SQRT2;
      ctx.moveTo(cx - rr, cy - rr); ctx.lineTo(cx + rr, cy + rr);
      ctx.moveTo(cx - rr, cy + rr); ctx.lineTo(cx + rr, cy - rr);
      ctx.stroke();
    }
    ctx.restore();

    requestAnimationFrame(drawOverlay);
  }

  function pointerToNorm(e){
    const rect = overlay.getBoundingClientRect();
    const x = (e.clientX - rect.left) / rect.width;
    const y = (e.clientY - rect.top) / rect.height;
    return [ clamp(x,0,1), clamp(y,0,1) ];
  }

  let dragging = false;
  overlay.addEventListener('pointerdown', e => {
    if (locked) return;
    dragging = true;
    overlay.setPointerCapture(e.pointerId);
    [cxNorm, cyNorm] = pointerToNorm(e);
  });
  overlay.addEventListener('pointermove', e => {
    if(!dragging || locked) return;
    [cxNorm, cyNorm] = pointerToNorm(e);
  });
  overlay.addEventListener('pointerup', e => {
    if (locked) return;
    dragging = false;
    overlay.releasePointerCapture(e.pointerId);
  });

  // Controls
  if (sizeSlider) sizeSlider.addEventListener('input', e => {
    radiusPct = parseFloat(e.target.value);
    sizeChips.forEach(c => setActive(c, false));
  });
  sizeChips.forEach(chip => {
    chip.addEventListener('click', () => {
      const v = parseFloat(chip.dataset.size);
      radiusPct = v;
      sizeSlider.value = v;
      sizeChips.forEach(c => setActive(c, c===chip));
    });
  });

  qualitySlider.addEventListener('input', e => qv.textContent = String(e.target.value));
  gridBtn.addEventListener('click', () => setActive(gridBtn, !isActive(gridBtn)));
  lockBtn.addEventListener('click', () => { locked = !locked; setActive(lockBtn, locked); });
  recenterBtn.addEventListener('click', () => { cxNorm = 0.5; cyNorm = 0.5; });
  fitBtn.addEventListener('click', () => { fitInside = !fitInside; setActive(fitBtn, fitInside); });

  document.getElementById('switch-source').addEventListener('click', async () => {
    facingMode = (facingMode === 'environment') ? 'user' : 'environment';
    await startCamera();
  });


  zoomSlider.addEventListener('input', async (e) => {
    if (!track) return;
    const z = parseFloat(e.target.value);
    try{
      await track.applyConstraints({ advanced: [{ zoom: z }] });
      zv.textContent = z.toFixed(1) + '×';
    }catch(err){ console.warn('zoom apply failed', err); }
  });
fileInput.addEventListener('change', async (e) => {
    const file = e.target.files?.[0];
    if(!file) return;
    try{
      const bmp = await loadBitmap(file);
      // Show in stage as background
      if (photoObjUrl){ try{ URL.revokeObjectURL(photoObjUrl); }catch(_e){} }
      photoObjUrl = URL.createObjectURL(file);
      if (photoPreview){
        photoPreview.src = photoObjUrl;
        photoPreview.style.display = 'block';
      }
      // Stop camera (optional) and switch to photo mode
      try{ stopCamera(); }catch(_e){}
      usingPhoto = true;
      if (backBtn) backBtn.classList.remove('hidden');
      updateStageVisual();
      photoBitmap = bmp;
      // Ensure overlay keeps animating
      requestAnimationFrame(drawOverlay);
    }catch(err){
      console.warn('photo load failed', err);
      alert('画像の読み込みに失敗しました。別の写真でお試しください。');
    }
  });

  captureBtn.addEventListener('click', async () => {
    flashOnce();
    try{
      if (usingPhoto && photoBitmap){
        await captureFromBitmap(photoBitmap);
      } else if (video.videoWidth && video.videoHeight && currentStream){
        await captureFromVideo();
      } else if (fileInput.files?.[0]){
        const bmp = await loadBitmap(fileInput.files[0]);
        await captureFromBitmap(bmp);
      } else {
        alert('カメラまたは画像が利用できません。');
      }
    }catch(err){
      console.warn('capture failed', err);
    }
  });

  shareBtn.addEventListener('click', async () => {
    if (!latestBlobUrl){ alert('まだ保存画像がありません。撮影してください。'); return; }
    if (navigator.share){
      try{
        // fetch the blob to share via File
        const res = await fetch(latestBlobUrl);
        const blob = await res.blob();
        const file = new File([blob], 'CTMRI_latest.jpg', { type: 'image/jpeg' });
        await navigator.share({ files:[file], title:'CT/MRI Crop', text:'丸枠内トリミング画像' });
      }catch(e){ console.warn('share failed', e); }
    } else {
      alert('この端末/ブラウザはWeb Share APIに未対応です。保存リンクから共有してください。');
    }
  });

  function displayedDrawRect(){
    const vw = video.videoWidth || 1280;
    const vh = video.videoHeight || 720;
    const cw = stage.clientWidth;
    const ch = stage.clientHeight;
    const scale = Math.min(cw / vw, ch / vh);
    const drawW = vw * scale;
    const drawH = vh * scale;
    const offsetX = (cw - drawW) / 2;
    const offsetY = (ch - drawH) / 2;
    return {vw, vh, scale, drawW, drawH, offsetX, offsetY};
  }

  async function captureFromVideo(){
    const {vw, vh, scale, drawW, drawH, offsetX, offsetY} = displayedDrawRect();
    const cxDisp = cxNorm * stage.clientWidth;
    const cyDisp = cyNorm * stage.clientHeight;
    const rDisp = Math.min(stage.clientWidth, stage.clientHeight) * radiusPct;

    const cxSrc = (cxDisp - offsetX) / scale;
    const cySrc = (cyDisp - offsetY) / scale;
    const rSrc  = rDisp / scale;

    const blobUrl = await cropAndExport(video, vw, vh, cxSrc, cySrc, rSrc);
    presentDownload(blobUrl);
  }

  async function captureFromBitmap(bmp){
    const vw = (bmp.width || bmp.naturalWidth);
    const vh = (bmp.height || bmp.naturalHeight);
    const cw = stage.clientWidth, ch = stage.clientHeight;
    const scale = Math.min(cw / vw, ch / vh);
    const drawW = vw * scale, drawH = vh * scale;
    const offsetX = (cw - drawW)/2, offsetY=(ch - drawH)/2;

    const cxDisp = cxNorm * cw;
    const cyDisp = cyNorm * ch;
    const rDisp  = Math.min(cw, ch) * radiusPct;

    const cxSrc = (cxDisp - offsetX) / scale;
    const cySrc = (cyDisp - offsetY) / scale;
    const rSrc  = rDisp / scale;

    const blobUrl = await cropAndExport(bmp, vw, vh, cxSrc, cySrc, rSrc);
    presentDownload(blobUrl);
  }async function cropAndExport(source, vw, vh, cxSrc, cySrc, rSrc){
    const x1 = Math.max(0, Math.floor(cxSrc - rSrc));
    const y1 = Math.max(0, Math.floor(cySrc - rSrc));
    const x2 = Math.min(vw, Math.ceil(cxSrc + rSrc));
    const y2 = Math.min(vh, Math.ceil(cySrc + rSrc));
    const sw = x2 - x1, sh = y2 - y1;
    const side = Math.max(sw, sh);

    // draw square crop
    const square = new OffscreenCanvas(side, side);
    const sctx = square.getContext('2d', { alpha: false });
    // 塗りつぶし（丸の外は黒）
    sctx.fillStyle = '#000'; sctx.fillRect(0,0,side,side);
    const dx = Math.floor((side - sw)/2);
    const dy = Math.floor((side - sh)/2);
    sctx.drawImage(source, x1, y1, sw, sh, dx, dy, sw, sh);
    // 円マスク（エッジをわずかに柔らかく）
    sctx.save();
    sctx.globalCompositeOperation = 'destination-in';
    sctx.beginPath();
    sctx.arc(side/2, side/2, Math.min(sw, sh)/2, 0, Math.PI*2);
    sctx.closePath();
    sctx.fill();
    sctx.restore();

    // 出力は正方形1080px
    const out = new OffscreenCanvas(OUTPUT_SIZE, OUTPUT_SIZE);
    const octx = out.getContext('2d', { alpha: false });
    octx.imageSmoothingQuality = 'high';
    octx.drawImage(square, 0, 0, OUTPUT_SIZE, OUTPUT_SIZE);

    const quality = parseInt(qualitySlider.value) / 100;
    const blob = await out.convertToBlob({ type:'image/jpeg', quality });
    const url = URL.createObjectURL(blob);
    latestBlobUrl = url;
    return url;
  }

  function presentDownload(url){
    const ts = formatTS(new Date());
    const filename = `CTMRI_${ts}.jpg`;
    dl.href = url;
    dl.download = filename;
    dl.classList.remove('hidden');

    // auto download (iOS Safari may ignore)
    try{
      const a = document.createElement('a');
      a.href = url; a.download = filename;
      document.body.appendChild(a); a.click(); a.remove();
    }catch(_e){ /* ignore */ }
  }

  function flashOnce(){
    flash.style.opacity = '0.7';
    setTimeout(() => { flash.style.opacity = '0'; }, 120);
  }

  // init
  if(navigator.mediaDevices && navigator.mediaDevices.getUserMedia){
    startCamera();
  }else{
    pickBtn.classList.remove('hidden');
  }

  document.addEventListener('keydown', e => {
    if(e.key === 'ArrowUp') cyNorm = clamp(cyNorm - 0.01, 0, 1);
    if(e.key === 'ArrowDown') cyNorm = clamp(cyNorm + 0.01, 0, 1);
    if(e.key === 'ArrowLeft') cxNorm = clamp(cxNorm - 0.01, 0, 1);
    if(e.key === 'ArrowRight') cxNorm = clamp(cxNorm + 0.01, 0, 1);
  });

  video.setAttribute('playsinline',''); video.setAttribute('muted','');

  function updateStopButton(){
    if (!stopBtn) return;
    stopBtn.textContent = cameraPaused ? '再開' : '終了';
  }
  async function toggleCamera(){
    try{
      if (cameraPaused){
        await startCamera();
        cameraPaused = false;
      } else {
        stopCamera();
        cameraPaused = true;
      }
    } catch(e){ console.warn('toggleCamera error', e); }
    updateStopButton();
  }
  if (stopBtn){ stopBtn.addEventListener('click', toggleCamera); }
  // Sync label on load (startCamera() is called elsewhere during init)
  updateStopButton();
  function updateStageVisual(){
    if (!video || !photoPreview) return;
    if (usingPhoto){
      video.style.display = 'none';
      photoPreview.style.display = 'block';
    } else {
      video.style.display = '';
      if (photoPreview.src === ''){ photoPreview.style.display = 'none';
      updateStageVisual(); }
    }
  }

  if (backBtn){
    backBtn.addEventListener('click', async () => {
      try{
        clearPhotoPreview();
    if (backBtn) backBtn.classList.add('hidden');
        await startCamera();
        if (typeof cameraPaused !== 'undefined'){ cameraPaused = false; }
        if (typeof updateStopButton === 'function'){ updateStopButton(); }
      }catch(e){ console.warn('back-to-camera failed', e); }
      // Hide the back button after returning to camera
      backBtn.classList.add('hidden');
    });
  }

  // Fullscreen toggle for camera
  const fsBtn = document.getElementById('fs-toggle');
  const fsLabel = document.getElementById('fs-toggle-label');
  const stageWrap = document.querySelector('.stage-container');

  function updateFsLabel(){
    if (!fsLabel) return;
    fsLabel.textContent = document.body.classList.contains('fullscreen') ? '通常表示' : '全画面';
  }
  function toggleFullscreenCam(){
    if (!stageWrap) return;
    stageWrap.classList.toggle('shoot-full');
    document.body.classList.toggle('fullscreen');
    updateFsLabel();
    // After resizing, keep overlay in sync
    requestAnimationFrame(drawOverlay);
  }
  if (fsBtn){
    fsBtn.addEventListener('click', toggleFullscreenCam);
    updateFsLabel();
  }

  const fsShutter = document.getElementById('fs-shutter');
  if (fsShutter && captureBtn){
    fsShutter.addEventListener('click', () => {
      try { captureBtn.click(); } catch(e){ console.warn('fs-shutter failed', e); }
    });
  }
})();
</script>
</body>
</html>
