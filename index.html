<!DOCTYPE html>

<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1, viewport-fit=cover" name="viewport"/>
<title>画像切り取りカメラ（HTML版 v2・fixed）</title>
<style>
  :root{
    --bg:#0b0f14; --fg:#e9f0f5; --muted:#9fb0be; --accent:#2ecc71; --accent-2:#e74c3c; --card:#141a21; --btn:#1f2833; --ring:#27ae60; --yellow:#f1c40f;
  }
  html,body{ margin:0; height:100%; background:var(--bg); color:var(--fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN","Yu Gothic",sans-serif; }
  .app{ display:flex; flex-direction:column; height:100%; }
  header, footer{ padding: env(safe-area-inset-top) 16px 8px 16px; }
  header{ display:flex; flex-direction:column; gap:10px; background:linear-gradient(180deg, #101723, #0b0f14 60%); box-shadow: 0 1px 0 rgba(255,255,255,0.05) inset; }
  .row{ display:flex; align-items:center; gap:12px; flex-wrap:wrap; }
  .title{ font-weight:700; letter-spacing:0.3px; font-size: clamp(16px, 2.8vw, 22px); }
  .grow{ flex:1; }
  .chip, .toggle, .btn, .link-like{ border-radius:14px; border:1px solid rgba(255,255,255,0.08); background:var(--btn); color:var(--fg); font-weight:700; }
  .chip{ padding:10px 12px; font-size:14px; }
  .chip[data-active="true"]{ outline:2px solid var(--ring); background: rgba(46,204,113,0.12); }
  .control{ display:flex; align-items:center; gap:10px; background:var(--card); padding:10px 12px; border-radius:14px; box-shadow:0 2px 8px rgba(0,0,0,0.25); }
  .control label{ color:var(--muted); font-size: 13px; }
  .toggle{ padding:12px 14px; font-size:14px; }
  .toggle[data-active="true"]{ outline: 2px solid var(--ring); background: rgba(46,204,113,0.12); }
  .toggle.warn[data-active="true"]{ outline-color: var(--yellow); background: rgba(241,196,15,0.12); }
  .link-like{ background:transparent; color:var(--muted); }
  .stage{ position:relative; flex:1; min-height: 42vh; overflow:hidden; margin: 8px 0; }
  video#preview{ position:absolute; inset:0; width:100%; height:100%; object-fit:cover; background:#000; }
  canvas#overlay{ position:absolute; inset:0; width:100%; height:100%; touch-action:none; }
  .flash{ position:absolute; inset:0; background:#fff; opacity:0; pointer-events:none; transition: opacity 120ms ease-out; }
  footer{ padding: 10px 16px calc(10px + env(safe-area-inset-bottom)) 16px; display:flex; gap:12px; align-items:center; justify-content:space-between; background:linear-gradient(0deg, #101723, #0b0f14 60%); border-top: 1px solid rgba(255,255,255,0.05); }
  .btn{ border:none; padding:18px 26px; font-size: clamp(18px, 4.2vw, 22px); background: var(--accent); color:#02130a; box-shadow: 0 6px 24px rgba(46,204,113,0.35); }
  .btn:active{ transform: translateY(1px); }
  .btn.secondary{ background: var(--accent-2); color:#fff; box-shadow:0 6px 24px rgba(231,76,60,0.35); }
  .btn.ghost{ background:transparent; color:var(--muted); border:1px solid rgba(255,255,255,0.15); }
  .stack{ display:flex; align-items:center; gap:12px; flex-wrap:wrap; }
  .hidden{ display:none; }
  .hint{ color:var(--muted); font-size:12px; }
  .btn-capture{ width:90px; height:90px; border-radius:50%; background:#fff; border:6px solid #ccc; box-shadow:0 4px 14px rgba(0,0,0,0.35); display:flex; align-items:center; justify-content:center; }
  .btn-capture:active{ transform: scale(0.92); border-color:#999; }
  html, body { height:100%; min-height:100%; margin:0; padding:0; background:#000; }
  .stage-container{ position:relative; }
  .stage > video#preview, .stage > img#photo-preview, .stage > canvas#overlay{ position:absolute; inset:0; width:100%; height:100%; object-fit:cover; }
  .fs-btn{ position:absolute; top:calc(env(safe-area-inset-top) + 8px); right:8px; z-index:1000; border:1px solid #888; background:rgba(0,0,0,.45); color:#fff; padding:8px 10px; border-radius:999px; font-size:14px; backdrop-filter: blur(4px); }
  .shoot-full{ position:fixed; inset:0; width:100vw; height:100svh; z-index:9990; background:#000; }
  @supports (height: 100lvh){ .shoot-full{ height:100lvh; } }
  @supports (height: 100dvh){ .shoot-full{ height:100dvh; } }
  @supports (-webkit-touch-callout: none){ .shoot-full{ height:-webkit-fill-available; } }
  .shoot-full > .stage{ width:100%; height:100%; }
  body.fullscreen .app-title, body.fullscreen header, body.fullscreen footer{ display:none !important; }
  body.fullscreen .stage > video#preview, body.fullscreen .stage > img#photo-preview{ object-fit: cover; }
  .fs-shutter{ position:absolute; left:50%; transform: translateX(-50%); bottom: calc(env(safe-area-inset-bottom) + 16px); z-index: 1001; width: 72px; height: 72px; border-radius: 50%; background: #fff; border: none; box-shadow: 0 2px 12px rgba(0,0,0,.35), inset 0 0 0 2px rgba(255,255,255,.9); display: none; }
  body.fullscreen .fs-shutter{ display: block; }
  body.fullscreen #capture{ display:none !important; }
  .capture-row{ background:#000; }
  .chips-label{ display:inline-block; margin-right: 10px; font-size: 14px; color: #fff; opacity: 0.9; letter-spacing: 0.02em; }
  header .chips-label{ color: inherit; opacity: 0.9; }
  header .row{ position: relative; display:flex; align-items:center; gap:10px; }
  .row-center-capture{ position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); display: flex; align-items: center; justify-content: center; pointer-events: none; }
  .row-center-capture > #capture{ pointer-events: auto; }
  #capture.btn-capture{ width: 72px; height: 72px; border-radius: 50%; }
  #zoom-wrap, #zoom { display: none !important; }
  #stop{ display:none !important; }
  .push-right{ margin-left:auto; }

  /* Step1: toast + spinner + larger tap targets */
  .toast {
    position: fixed;
    left: 50%;
    transform: translateX(-50%);
    bottom: calc(16px + env(safe-area-inset-bottom));
    background: rgba(0,0,0,0.85);
    color: #fff;
    padding: 10px 14px;
    border-radius: 999px;
    font-size: 14px;
    box-shadow: 0 4px 16px rgba(0,0,0,0.35);
    opacity: 0;
    transition: opacity 0.2s ease;
    pointer-events: none;
    z-index: 2000;
  }
  .toast.show { opacity: 1; }
  .spinner-backdrop {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.35);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 1500;
  }
  .spinner-backdrop.show { display: flex; }
  .spinner {
    width: 56px; height: 56px;
    border-radius: 50%;
    border: 6px solid rgba(255,255,255,0.35);
    border-top-color: #fff;
    animation: spin 0.8s linear infinite;
  }
  @keyframes spin { to { transform: rotate(360deg); } }
  /* bigger tap areas for key toggles */
  .toggle, .chip, .btn { min-height: 44px; }

  /* Step2: Contrast & focus */
  :root{
    --bg:#0b0f14; --fg:#eef4f8; --muted:#b8c5cf; --accent:#2ecc71; --accent-2:#e74c3c; --card:#141a21; --btn:#1a2230; --ring:#27ae60; --yellow:#f1c40f;
  }
  .control { border:1px solid rgba(255,255,255,0.12); }
  .toggle, .chip, .btn, .link-like { border:1px solid rgba(255,255,255,0.18); }
  .toggle:focus-visible, .chip:focus-visible, .btn:focus-visible, #fs-toggle:focus-visible {
    outline:2px solid var(--ring);
    outline-offset:2px;
  }
  .hint{ color:var(--muted); opacity:0.95; }
  .btn-capture{ border-color:#ddd; }
  .stage > video#preview, .stage > img#photo-preview, .stage > canvas#overlay{ object-fit: cover; }
  /* overlay dim slightly stronger for clarity */
  canvas#overlay{ }
</style>
</head>
<body>
<div class="app">
<div class="app-title" style="text-align:center; font-weight:700; font-size:20px; padding:10px;">画像切り取りカメラ（HTML版 v2・fixed）</div>
<div class="stage-container">
<main class="stage" id="stage">
<video autoplay="" id="preview" muted="" playsinline=""></video>
<img alt="" id="photo-preview"/>
<canvas id="overlay"></canvas>
<div class="flash" id="flash"></div>
</main>
<button aria-label="撮影" class="fs-shutter" id="fs-shutter"></button>
<button class="fs-btn" id="fs-toggle"><span id="fs-toggle-label">全画面</span></button>
</div>
<header>
<div class="row capture-row">
<button class="toggle" id="switch-source" title="前面/背面を切替">カメラ切替</button>
<div class="grow">
<span class="row-center-capture">
<button aria-label="撮影" class="btn btn-capture" id="capture"></button>
</span>
</div>
<label class="toggle link-like" for="file-fallback" id="pick-file">写真から読み込む</label>
</div>
<div class="row">
<div aria-label="丸枠サイズ" class="control">
<div class="chips"><span aria-hidden="true" class="chips-label">丸枠</span>
<button aria-pressed="true" class="chip" data-active="true" data-size="0.35">S</button>
<button aria-pressed="false" class="chip" data-active="false" data-size="0.42">M</button>
<button aria-pressed="false" class="chip" data-active="false" data-size="0.50">L</button>
</div>
</div>
</div>
<div class="row">
<button aria-pressed="true" class="toggle" data-active="true" id="grid">グリッド</button>
<button class="toggle warn" data-active="false" id="lock" title="ドラッグを無効化">ロック</button>
<button class="toggle" id="recenter">中央に戻す</button>
<button class="toggle" data-active="true" id="fit-inside" title="丸枠を映像内に制限">枠のはみ出し防止</button>
</div>
<div class="row">
<button class="toggle" id="stop-proxy">終了 ↔ 再開</button>
</div>
<div class="row">
<div class="control hidden" id="zoom-wrap">
<label for="zoom">ズーム</label>
<input id="zoom" max="1" min="1" step="0.1" type="range" value="1"/>
<span id="zv">1.0×</span>
</div>
<input accept="image/*" capture="environment" class="visually-hidden-file" id="file-fallback" type="file"/>
<button class="toggle link-like hidden" id="back-to-camera" style="margin-left:8px;">戻る</button>
<button class="toggle" id="stop" style="margin-left:8px;">再開</button>
</div>
</header>
<footer style="display:flex; align-items:center; justify-content:space-between; gap:8px; width:100%; padding:12px 16px;">
<div class="hint">iPhoneはHTTPSでアクセス。保存はリンク長押しでもOK。</div>
<a class="btn ghost hidden" download="" id="dl">保存</a>
</footer>
</div><div aria-live="polite" class="toast" id="toast">保存しました</div><div aria-live="assertive" class="spinner-backdrop" id="spinner" role="alert"><div class="spinner"></div></div>
<script>
(function(){
  // --- Helpers ---
  function getActiveChipSize(){
    const active = document.querySelector('.chip[data-active="true"]');
    if (active) return parseFloat(active.dataset.size);
    const first = document.querySelector('.chip[data-size]');
    return first ? parseFloat(first.dataset.size) : 0.42; // fallback M
  }
  function markActiveChip(target){
    document.querySelectorAll('.chip[data-size]').forEach(b => b.setAttribute('data-active','false'));
    if (target) target.setAttribute('data-active','true');
  }
  const video = document.getElementById('preview');
  const overlay = document.getElementById('overlay');
  const ctx = overlay.getContext('2d');
  const stage = document.getElementById('stage');
  const flash = document.getElementById('flash');

  let cameraPaused = false;
  const sizeChips = [...document.querySelectorAll('.chip')];
  sizeChips.forEach(btn => {
    btn.addEventListener('click', function(){
      const v = parseFloat(this.dataset.size);
      if (Number.isFinite(v)) { radiusPct = v; }
      markActiveChip(this); saveState();
      drawOverlay();
    });
  });

  const gridBtn = document.getElementById('grid');
  const lockBtn = document.getElementById('lock');
  const recenterBtn = document.getElementById('recenter');
  const fitBtn = document.getElementById('fit-inside');
  const captureBtn = document.getElementById('capture');
  const stopBtn = document.getElementById('stop');
  const switchBtn = document.getElementById('switch-source');
  const dl = document.getElementById('dl');
  const backBtn = document.getElementById('back-to-camera');
  const fileInput = document.getElementById('file-fallback');
  const pickBtn = document.getElementById('pick-file'); // HTMLと一致
  const photoPreview = document.getElementById('photo-preview');

  // Step1 helpers: localStorage, toast, spinner, double-tap
  const LS = {
    get(k, d=null){ try{ const v = localStorage.getItem(k); return v===null?d:JSON.parse(v); }catch(_){ return d; } },
    set(k, v){ try{ localStorage.setItem(k, JSON.stringify(v)); }catch(_){ } },
  };
  const toastEl = document.getElementById('toast');
  const spinnerEl = document.getElementById('spinner');
  function showToast(msg, ms=2000){
    if (!toastEl) return;
    toastEl.textContent = msg;
    toastEl.classList.add('show');
    setTimeout(()=>toastEl.classList.remove('show'), ms);
  }
  function spinner(on){
    if (!spinnerEl) return;
    if (on) spinnerEl.classList.add('show');
    else spinnerEl.classList.remove('show');
  }
  // double-tap detection for overlay (iPhone)
  let lastTap = 0;
  function handleDoubleTap(e){
    const now = Date.now();
    if (now - lastTap < 350){ // double tap
      cxNorm = 0.5; cyNorm = 0.5;
    }
    lastTap = now;
  }


  let usingPhoto = false; let photoObjUrl = null; let photoBitmap = null;
  const zoomWrap = document.getElementById('zoom-wrap');
  const zoomSlider = document.getElementById('zoom');
  const zv = document.getElementById('zv');

  let showGrid = true;
  let radiusPct = getActiveChipSize();
  let cxNorm = 0.5; // 0..1
  let cyNorm = 0.5;
  let currentStream = null;
  let facingMode = 'environment';
  let latestBlobUrl = null;
  let track = null;
  let caps = null;
  let settings = null;
  let fitInside = true;
  let locked = false;

  function clearPhotoPreview(){
    usingPhoto = false;
    if (photoPreview){
      photoPreview.src = '';
      photoPreview.style.display = 'none';
      updateStageVisual();
    }
    if (photoObjUrl){ try{ URL.revokeObjectURL(photoObjUrl); }catch(_e){} photoObjUrl = null; }
    photoBitmap = null;
  }

  async function loadBitmap(file){
    if (window.createImageBitmap){
      try{ return await window.createImageBitmap(file); }catch(_e){ /* fallback */ }
    }
    return await new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = URL.createObjectURL(file);
    });
  }

  const OUTPUT_SIZE = 1080;
  function setActive(el, active){ el.dataset.active = active ? 'true' : 'false'; }
  function isActive(el){ return el?.dataset?.active === 'true'; }
  function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }
  function formatTS(d){ const z = n => String(n).padStart(2,'0'); return d.getFullYear()+ z(d.getMonth()+1)+ z(d.getDate()) + '_' + z(d.getHours()) + z(d.getMinutes()) + z(d.getSeconds()); }

  async function startCamera(){
    clearPhotoPreview();
    if (backBtn) backBtn.classList.add('hidden');
    updateStageVisual();
    stopCamera();
    const constraints = {
      audio:false,
      video:{
        facingMode: { ideal: facingMode }, width: { ideal: 1920 }, height: { ideal: 1080 }, frameRate: { ideal: 30 },
        advanced: [ { focusMode: "continuous" }, { exposureMode: "continuous" } ]
      }
    };
    try{
      currentStream = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject = currentStream;
      await video.play();
      track = currentStream.getVideoTracks()[0];
      try {
        caps = track.getCapabilities?.() || null;
        settings = track.getSettings?.() || null;
        if (caps && caps.zoom){
          const min = caps.zoom.min || 1;
          const max = caps.zoom.max || 1;
          zoomSlider.min = min; zoomSlider.max = max; zoomSlider.step = caps.zoom.step || 0.1; zoomSlider.value = settings.zoom || 1;
          zv.textContent = (parseFloat(zoomSlider.value)).toFixed(1) + '×';
          zoomWrap.classList.remove('hidden');
        } else { zoomWrap.classList.add('hidden'); }
      } catch(e){ zoomWrap.classList.add('hidden'); }
      requestAnimationFrame(drawOverlay);

  // --- Persistence (Step1) ---
  // restore previous states
  try{
    const saved = LS.get('settings', {});
    if (typeof saved.cx === 'number') cxNorm = saved.cx;
    if (typeof saved.cy === 'number') cyNorm = saved.cy;
    if (typeof saved.radiusPct === 'number') radiusPct = saved.radiusPct;
    if (typeof saved.showGrid === 'boolean'){ showGrid = saved.showGrid; setActive(gridBtn, showGrid); }
    if (typeof saved.fitInside === 'boolean'){ fitInside = saved.fitInside; setActive(fitBtn, fitInside); }
    if (typeof saved.locked === 'boolean'){ locked = saved.locked; setActive(lockBtn, locked); }
    if (typeof saved.facingMode === 'string'){ facingMode = saved.facingMode; }
    if (saved.activeSize){
      document.querySelectorAll('.chip[data-size]').forEach(b => {
        if (b.dataset.size === String(saved.activeSize)){ markActiveChip(b); radiusPct = parseFloat(b.dataset.size); }
      });
    }
    if (typeof saved.fullscreen === 'boolean' && saved.fullscreen){
      // try to restore fullscreen UI state (CSS-only fullscreen for this app layout)
      document.querySelector('.stage-container')?.classList?.add('shoot-full');
      document.body.classList.add('fullscreen');
    }
  }catch(_e){}
  function saveState(){
    const activeChip = document.querySelector('.chip[data-active="true"]');
    const activeSize = activeChip ? activeChip.dataset.size : null;
    LS.set('settings', {
      cx: cxNorm, cy: cyNorm, radiusPct, showGrid: isActive(gridBtn),
      fitInside: isActive(fitBtn), locked, facingMode, activeSize,
      fullscreen: document.body.classList.contains('fullscreen')
    });
  }

    }catch(err){
      console.warn('getUserMedia失敗:', err);
      pickBtn?.classList?.remove('hidden');
      try{
        const isHTTPS = location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1';
        let msg = 'カメラの起動に失敗しました。';
        if (!isHTTPS){ msg += '\n・iPhone/Safariは HTTPS でアクセスしてください'; }
        if (err && err.name === 'NotAllowedError'){ msg += '\n・ブラウザの設定で カメラの許可 をONにしてください'; }
        msg += '\n・“写真から読み込む” で代替できます';
        showToast(msg, 4000);
      }catch(_e){}

    }
  }

  function stopCamera(){
    if(currentStream){ currentStream.getTracks().forEach(t => t.stop()); currentStream = null; track = null; }
  }

  function updateOverlaySize(){ overlay.width = stage.clientWidth; overlay.height = stage.clientHeight; }

  function displayedDrawRect(){
    const vw = video.videoWidth || 1280; const vh = video.videoHeight || 720;
    const cw = stage.clientWidth; const ch = stage.clientHeight;
    const scale = Math.min(cw / vw, ch / vh);
    const drawW = vw * scale; const drawH = vh * scale;
    const offsetX = (cw - drawW) / 2; const offsetY = (ch - drawH) / 2;
    return {vw, vh, scale, drawW, drawH, offsetX, offsetY};
  }

  function drawOverlay(){
    updateOverlaySize();
    const w = overlay.width, h = overlay.height;
    ctx.clearRect(0,0,w,h);

    let r = Math.min(w,h) * radiusPct;
    let cx = cxNorm * w; let cy = cyNorm * h;

    if (fitInside){
      const {drawW, drawH, offsetX, offsetY} = displayedDrawRect();
      cx = clamp(cx, offsetX + r, offsetX + drawW - r);
      cy = clamp(cy, offsetY + r, offsetY + drawH - r);
      cxNorm = cx / w; cyNorm = cy / h;
    }

    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0,0,w,h);
    ctx.globalCompositeOperation = 'destination-out';
    ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
    ctx.restore();

    ctx.save();
    // Outer ring shadow
    ctx.strokeStyle = '#000'; ctx.lineWidth = 6; ctx.beginPath(); ctx.arc(cx,cy,r+6,0,Math.PI*2); ctx.stroke();
    // Main ring color switches when locked
    ctx.strokeStyle = locked ? '#f1c40f' : '#00FF66';
    ctx.lineWidth = 4; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.stroke();
    // Lock icon when locked
    if (locked){
      ctx.save();
      ctx.font = Math.max(16, Math.floor(r*0.25)) + 'px system-ui, -apple-system, Segoe UI, Roboto';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillStyle = '#f1c40f';
      ctx.shadowColor = 'rgba(0,0,0,0.7)'; ctx.shadowBlur = 4; ctx.shadowOffsetY = 1;
      ctx.fillText('🔒', cx + r*0.65, cy - r*0.65);
      ctx.restore();
    }

    if(isActive(gridBtn)){
      ctx.strokeStyle = 'rgba(255,255,255,0.95)'; ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(cx - r, cy); ctx.lineTo(cx + r, cy);
      ctx.moveTo(cx, cy - r); ctx.lineTo(cx, cy + r);
      const rr = r / Math.SQRT2;
      ctx.moveTo(cx - rr, cy - rr); ctx.lineTo(cx + rr, cy + rr);
      ctx.moveTo(cx - rr, cy + rr); ctx.lineTo(cx + rr, cy - rr);
      ctx.stroke();
    }
    ctx.restore();

    requestAnimationFrame(drawOverlay);

  // --- Persistence (Step1) ---
  // restore previous states
  try{
    const saved = LS.get('settings', {});
    if (typeof saved.cx === 'number') cxNorm = saved.cx;
    if (typeof saved.cy === 'number') cyNorm = saved.cy;
    if (typeof saved.radiusPct === 'number') radiusPct = saved.radiusPct;
    if (typeof saved.showGrid === 'boolean'){ showGrid = saved.showGrid; setActive(gridBtn, showGrid); }
    if (typeof saved.fitInside === 'boolean'){ fitInside = saved.fitInside; setActive(fitBtn, fitInside); }
    if (typeof saved.locked === 'boolean'){ locked = saved.locked; setActive(lockBtn, locked); }
    if (typeof saved.facingMode === 'string'){ facingMode = saved.facingMode; }
    if (saved.activeSize){
      document.querySelectorAll('.chip[data-size]').forEach(b => {
        if (b.dataset.size === String(saved.activeSize)){ markActiveChip(b); radiusPct = parseFloat(b.dataset.size); }
      });
    }
    if (typeof saved.fullscreen === 'boolean' && saved.fullscreen){
      // try to restore fullscreen UI state (CSS-only fullscreen for this app layout)
      document.querySelector('.stage-container')?.classList?.add('shoot-full');
      document.body.classList.add('fullscreen');
    }
  }catch(_e){}
  function saveState(){
    const activeChip = document.querySelector('.chip[data-active="true"]');
    const activeSize = activeChip ? activeChip.dataset.size : null;
    LS.set('settings', {
      cx: cxNorm, cy: cyNorm, radiusPct, showGrid: isActive(gridBtn),
      fitInside: isActive(fitBtn), locked, facingMode, activeSize,
      fullscreen: document.body.classList.contains('fullscreen')
    });
  }

  }

  function pointerToNorm(e){
    const rect = overlay.getBoundingClientRect();
    const x = (e.clientX - rect.left) / rect.width;
    const y = (e.clientY - rect.top) / rect.height;
    return [ clamp(x,0,1), clamp(y,0,1) ];
  }

  let dragging = false;
  overlay.addEventListener('pointerdown', e => { if (locked) return; dragging = true; overlay.setPointerCapture(e.pointerId); [cxNorm, cyNorm] = pointerToNorm(e); });
  overlay.addEventListener('pointermove', e => { if(!dragging || locked) return; [cxNorm, cyNorm] = pointerToNorm(e); });
  overlay.addEventListener('pointerup', e => { if (locked) return; dragging = false; overlay.releasePointerCapture(e.pointerId); handleDoubleTap(e); });

  gridBtn.addEventListener('click', () => { setActive(gridBtn, !isActive(gridBtn)); saveState(); });
  lockBtn.addEventListener('click', () => { locked = !locked; setActive(lockBtn, locked); saveState(); });
  recenterBtn.addEventListener('click', () => { cxNorm = 0.5; cyNorm = 0.5; saveState(); });
  fitBtn.addEventListener('click', () => { fitInside = !fitInside; setActive(fitBtn, fitInside); saveState(); });

  switchBtn.addEventListener('click', async () => { facingMode = (facingMode === 'environment') ? 'user' : 'environment'; saveState(); await startCamera(); });

  zoomSlider.addEventListener('input', async (e) => {
    if (!track) return; const z = parseFloat(e.target.value);
    try{ await track.applyConstraints({ advanced: [{ zoom: z }] }); zv.textContent = z.toFixed(1) + '×'; }catch(err){ console.warn('zoom apply failed', err); }
  });

  fileInput.addEventListener('change', async (e) => {
    const file = e.target.files?.[0]; if(!file) return;
    try{
      const bmp = await loadBitmap(file);
      if (photoObjUrl){ try{ URL.revokeObjectURL(photoObjUrl); }catch(_e){} }
      photoObjUrl = URL.createObjectURL(file);
      if (photoPreview){ photoPreview.src = photoObjUrl; photoPreview.style.display = 'block'; }
      try{ stopCamera(); }catch(_e){}
      usingPhoto = true;
      if (backBtn) backBtn.classList.remove('hidden');
      updateStageVisual();
      photoBitmap = bmp;
      requestAnimationFrame(drawOverlay);

  // --- Persistence (Step1) ---
  // restore previous states
  try{
    const saved = LS.get('settings', {});
    if (typeof saved.cx === 'number') cxNorm = saved.cx;
    if (typeof saved.cy === 'number') cyNorm = saved.cy;
    if (typeof saved.radiusPct === 'number') radiusPct = saved.radiusPct;
    if (typeof saved.showGrid === 'boolean'){ showGrid = saved.showGrid; setActive(gridBtn, showGrid); }
    if (typeof saved.fitInside === 'boolean'){ fitInside = saved.fitInside; setActive(fitBtn, fitInside); }
    if (typeof saved.locked === 'boolean'){ locked = saved.locked; setActive(lockBtn, locked); }
    if (typeof saved.facingMode === 'string'){ facingMode = saved.facingMode; }
    if (saved.activeSize){
      document.querySelectorAll('.chip[data-size]').forEach(b => {
        if (b.dataset.size === String(saved.activeSize)){ markActiveChip(b); radiusPct = parseFloat(b.dataset.size); }
      });
    }
    if (typeof saved.fullscreen === 'boolean' && saved.fullscreen){
      // try to restore fullscreen UI state (CSS-only fullscreen for this app layout)
      document.querySelector('.stage-container')?.classList?.add('shoot-full');
      document.body.classList.add('fullscreen');
    }
  }catch(_e){}
  function saveState(){
    const activeChip = document.querySelector('.chip[data-active="true"]');
    const activeSize = activeChip ? activeChip.dataset.size : null;
    LS.set('settings', {
      cx: cxNorm, cy: cyNorm, radiusPct, showGrid: isActive(gridBtn),
      fitInside: isActive(fitBtn), locked, facingMode, activeSize,
      fullscreen: document.body.classList.contains('fullscreen')
    });
  }

    }catch(err){ console.warn('photo load failed', err); alert('画像の読み込みに失敗しました。別の写真でお試しください。'); }
  });

  captureBtn.addEventListener('click', async () => { spinner(true);
    flashOnce();
    try{
      if (usingPhoto && photoBitmap){ await captureFromBitmap(photoBitmap); }
      else if (video.videoWidth && video.videoHeight && currentStream){ await captureFromVideo(); }
      else if (fileInput.files?.[0]){ const bmp = await loadBitmap(fileInput.files[0]); await captureFromBitmap(bmp); }
      else { alert('カメラまたは画像が利用できません。'); }
    }catch(err){ console.warn('capture failed', err); } finally { spinner(false); }
  });

  async function captureFromVideo(){
    const {vw, vh, scale, drawW, drawH, offsetX, offsetY} = displayedDrawRect();
    const cxDisp = cxNorm * stage.clientWidth; const cyDisp = cyNorm * stage.clientHeight; const rDisp = Math.min(stage.clientWidth, stage.clientHeight) * radiusPct;
    const cxSrc = (cxDisp - offsetX) / scale; const cySrc = (cyDisp - offsetY) / scale; const rSrc  = rDisp / scale;
    const blobUrl = await cropAndExport(video, vw, vh, cxSrc, cySrc, rSrc); presentDownload(blobUrl);
  }

  async function captureFromBitmap(bmp){
    const vw = (bmp.width || bmp.naturalWidth); const vh = (bmp.height || bmp.naturalHeight);
    const cw = stage.clientWidth, ch = stage.clientHeight; const scale = Math.min(cw / vw, ch / vh);
    const drawW = vw * scale, drawH = vh * scale; const offsetX = (cw - drawW)/2, offsetY=(ch - drawH)/2;
    const cxDisp = cxNorm * cw; const cyDisp = cyNorm * ch; const rDisp  = Math.min(cw, ch) * radiusPct;
    const cxSrc = (cxDisp - offsetX) / scale; const cySrc = (cyDisp - offsetY) / scale; const rSrc  = rDisp / scale;
    const blobUrl = await cropAndExport(bmp, vw, vh, cxSrc, cySrc, rSrc); presentDownload(blobUrl);
  }

  async function cropAndExport(source, vw, vh, cxSrc, cySrc, rSrc){
    const x1 = Math.max(0, Math.floor(cxSrc - rSrc));
    const y1 = Math.max(0, Math.floor(cySrc - rSrc));
    const x2 = Math.min(vw, Math.ceil(cxSrc + rSrc));
    const y2 = Math.min(vh, Math.ceil(cySrc + rSrc));
    const sw = x2 - x1, sh = y2 - y1; const side = Math.max(sw, sh);

    const square = new OffscreenCanvas(side, side);
    const sctx = square.getContext('2d', { alpha: false });
    sctx.fillStyle = '#000'; sctx.fillRect(0,0,side,side);
    const dx = Math.floor((side - sw)/2); const dy = Math.floor((side - sh)/2);
    sctx.drawImage(source, x1, y1, sw, sh, dx, dy, sw, sh);
    sctx.save(); sctx.globalCompositeOperation = 'destination-in'; sctx.beginPath(); sctx.arc(side/2, side/2, Math.min(sw, sh)/2, 0, Math.PI*2); sctx.closePath(); sctx.fill(); sctx.restore();

    const out = new OffscreenCanvas(OUTPUT_SIZE, OUTPUT_SIZE);
    const octx = out.getContext('2d', { alpha: false });
    octx.imageSmoothingQuality = 'high';
    octx.drawImage(square, 0, 0, OUTPUT_SIZE, OUTPUT_SIZE);

    const quality = 0.9; // 固定値（JPEG画質スライダーを削除したため）
    const blob = await out.convertToBlob({ type:'image/jpeg', quality });
    const url = URL.createObjectURL(blob);
    latestBlobUrl = url;
    return url;
  }

  function presentDownload(url){
    const ts = formatTS(new Date());
    const filename = `CTMRI_${ts}.jpg`;
    dl.href = url; dl.download = filename; dl.classList.remove('hidden'); showToast('保存しました：' + filename);
    try{ const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); a.remove(); }catch(_e){ /* ignore */ }
  }

  function flashOnce(){ flash.style.opacity = '0.7'; setTimeout(() => { flash.style.opacity = '0'; }, 120); }

  if(navigator.mediaDevices && navigator.mediaDevices.getUserMedia){
    const isHTTPS = location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1';
    if (!isHTTPS){ showToast('iPhone/SafariではHTTPS接続でカメラが動作します', 3500); }
    startCamera();
  } else {
    pickBtn?.classList?.remove('hidden');
    showToast('この端末ではカメラAPIが利用できません。“写真から読み込む”をご利用ください', 4000);
  }

  document.addEventListener('keydown', e => {
    if(e.key === 'ArrowUp') cyNorm = clamp(cyNorm - 0.01, 0, 1);
    if(e.key === 'ArrowDown') cyNorm = clamp(cyNorm + 0.01, 0, 1);
    if(e.key === 'ArrowLeft') cxNorm = clamp(cxNorm - 0.01, 0, 1);
    if(e.key === 'ArrowRight') cxNorm = clamp(cxNorm + 0.01, 0, 1);
  });

  video.setAttribute('playsinline',''); video.setAttribute('muted','');

  function updateStopButton(){ if (!stopBtn) return; stopBtn.textContent = cameraPaused ? '再開' : '終了'; }
  async function toggleCamera(){
    try{
      if (cameraPaused){ await startCamera(); cameraPaused = false; }
      else { stopCamera(); cameraPaused = true; }
    } catch(e){ console.warn('toggleCamera error', e); }
    updateStopButton();
  }
  if (stopBtn){ stopBtn.addEventListener('click', toggleCamera); }
  updateStopButton();

  function updateStageVisual(){
    if (!video || !photoPreview) return;
    if (usingPhoto){ video.style.display = 'none'; photoPreview.style.display = 'block'; }
    else { video.style.display = ''; photoPreview.style.display = 'none'; }
  }

  if (backBtn){
    backBtn.addEventListener('click', async () => {
      try{ clearPhotoPreview(); if (backBtn) backBtn.classList.add('hidden'); await startCamera(); cameraPaused = false; updateStopButton(); }
      catch(e){ console.warn('back-to-camera failed', e); }
    });
  }

  const fsBtn = document.getElementById('fs-toggle');
  const fsLabel = document.getElementById('fs-toggle-label');
  const stageWrap = document.querySelector('.stage-container');
  function updateFsLabel(){ if (!fsLabel) return; fsLabel.textContent = document.body.classList.contains('fullscreen') ? '通常表示' : '全画面'; }
  function toggleFullscreenCam(){ if (!stageWrap) return; stageWrap.classList.toggle('shoot-full'); document.body.classList.toggle('fullscreen'); updateFsLabel(); requestAnimationFrame(drawOverlay);

  // --- Persistence (Step1) ---
  // restore previous states
  try{
    const saved = LS.get('settings', {});
    if (typeof saved.cx === 'number') cxNorm = saved.cx;
    if (typeof saved.cy === 'number') cyNorm = saved.cy;
    if (typeof saved.radiusPct === 'number') radiusPct = saved.radiusPct;
    if (typeof saved.showGrid === 'boolean'){ showGrid = saved.showGrid; setActive(gridBtn, showGrid); }
    if (typeof saved.fitInside === 'boolean'){ fitInside = saved.fitInside; setActive(fitBtn, fitInside); }
    if (typeof saved.locked === 'boolean'){ locked = saved.locked; setActive(lockBtn, locked); }
    if (typeof saved.facingMode === 'string'){ facingMode = saved.facingMode; }
    if (saved.activeSize){
      document.querySelectorAll('.chip[data-size]').forEach(b => {
        if (b.dataset.size === String(saved.activeSize)){ markActiveChip(b); radiusPct = parseFloat(b.dataset.size); }
      });
    }
    if (typeof saved.fullscreen === 'boolean' && saved.fullscreen){
      // try to restore fullscreen UI state (CSS-only fullscreen for this app layout)
      document.querySelector('.stage-container')?.classList?.add('shoot-full');
      document.body.classList.add('fullscreen');
    }
  }catch(_e){}
  function saveState(){
    const activeChip = document.querySelector('.chip[data-active="true"]');
    const activeSize = activeChip ? activeChip.dataset.size : null;
    LS.set('settings', {
      cx: cxNorm, cy: cyNorm, radiusPct, showGrid: isActive(gridBtn),
      fitInside: isActive(fitBtn), locked, facingMode, activeSize,
      fullscreen: document.body.classList.contains('fullscreen')
    });
  }
 }
  if (fsBtn){ fsBtn.addEventListener('click', toggleFullscreenCam); updateFsLabel(); }

  const fsShutter = document.getElementById('fs-shutter');
  if (fsShutter && captureBtn){ fsShutter.addEventListener('click', () => { try { captureBtn.click(); } catch(e){ console.warn('fs-shutter failed', e); } }); }

  const stopProxy = document.getElementById('stop-proxy');
  const stopReal = document.getElementById('stop');
  if (stopProxy && stopReal){ stopProxy.addEventListener('click', () => { try{ stopReal.click(); }catch(e){} }); }
})();
</script>
</body>
</html>
